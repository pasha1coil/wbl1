1 - Какой самый эффективный способ конкатенации строк?
Ответ: через strings.Builder пакета strings

2. - Что такое интерфейсы, как они применяются в Go?
Ответ: интерфейс - это структура, в которой описаны методы, которые должны быть реализованы для
других структур, которые будут удовлетворять этому интерфейсу.
Удовлетворение интерфейсу поддерживается на неявном уровне.
То есть для объекта достаточно описать реализацию методов интерфейса.
И объект, без дополнительных объявлений в кодовой базе, начинает удовлетворять этому интерфейсу.

3. - Чем отличаются RWMutex от Mutex?
Ответ: RWMutex - блокирует блок кода на запись, Mutex - блокирует блок кода как на запись так и на чтение

4. - Чем отличаются буферизированные и не буферизированные каналы?
Ответ: буферизированный канал это канал который имеет буфер определенный make(),не буферизированный
канал имеет nil буфер
1. Буферизация данных: Буферизированные каналы имеют внутренний буфер,
который позволяет временно хранить данные перед их чтением или записью.
Это дает возможность асинхронной коммуникации между процессами или потоками,
так как отправитель может продолжить свою работу, даже если получатель занят или не готов к приему данных.
В не буферизированных каналах данные передаются немедленно, и отправитель будет заблокирован до тех пор,
пока получатель не прочтет данные.

2. Размер буфера: В размере буфера отличаются буферизированные и не буферизированные каналы.
В буферизированных каналах может быть определенный размер буфера, и если буфер заполнен,
то отправитель будет заблокирован до тех пор, пока получатель не освободит место в буфере.
В не буферизированных каналах буфера нет, поэтому отправитель и получатель должны быть готовы к чтению
и записи данных в момент их передачи.

3. Способ обмена данными: В буферизированных каналах данные могут быть переданы как синхронно,
так и асинхронно, так как отправитель может продолжить работу после записи данных в буфер.
В не буферизированных каналах данные передаются только синхронно, поскольку отправитель блокируется
до тех пор, пока получатель не прочтет данные.

4. Пропускная способность: Буферизированные каналы могут иметь большую пропускную способность,
так как данные буферизуются и передаются асинхронно. В не буферизированных каналах пропускная
способность ограничена моментальной передачей данных.

5.-Какой размер у структуры struct{}{}?
Ответ: 0 байт,  в основном используется для создания множеств, там где важен только ключ

6.- Есть ли в Go перегрузка методов или операторов?
Ответ: Перегрузка методов или операторов в Go отсутствует.
В Go нельзя создавать несколько методов или функций с одинаковыми именами,
но разными типами параметров или возвращаемых значений, как это можно делать в
некоторых других языках программирования с поддержкой перегрузки.
С целью поддержки различных операций и функциональности над разными типами данных,
в Go используется интерфейсы. Интерфейсы позволяют объединять методы с одинаковыми именами,
но реализуемые разными типами данных.

7. - В какой последовательности будут выведены элементы map[int]int?

    Пример:
    m[0]=1
    m[1]=124
    m[2]=281
Ответ: если выводить как fmt.Print(m) = в порядке возрастания по ключу
Если вывод производить в цикле range, то в рандомном порядке


8.- В чем разница make и new?
Ответ: Функции 'new' и 'make' различаются тем, что: 'new' возвращает указатель вместо
значения возвращаемое функцией 'make'. 'make' имеет вариадический аргумент 'size'.
'make' выделяет память и инциализирует только объекты типов: slice, map, or chan.

9.- Сколько существует способов задать переменную типа slice или map?
1. Инициализация с использованием литерала:
slice := []int{}
map := map[string]string{str1:str2,str3:...}

2. Использование ключевого слова make:
slice :=make([]int, 10,20)
map := make(map[string]string)

3. Использование присваивания значения пустого значения типа:
var slice []int
var m map[string]string

4. Использование функции new для создания указателя на slice или map:
slice := new([]int)
map := new(map[string]string)

10.:
    Что выведет данная программа и почему?

    func update(p *int) {
      b := 2
      p = &b
    }

    func main() {
      var (
         a = 1
         p = &a
      )
      fmt.Println(*p)
      update(p)
      fmt.Println(*p)
    }

    Ответ:
    вывод будет в первом случае 1, и во втором тоже 1, чтобы поменять значение p с помощью
    update нужно сделать указатель на указатель и уже присвоить значение b, а не передавать адрес b
    указателю p,так как это происходит только в области видимости update и когда
    функция завершается в основном потоке p продолжает указывать на a, *p=b

11.:
    Что выведет данная программа и почему?


    func main() {
      wg := sync.WaitGroup{}
      for i := 0; i < 5; i++ {
         wg.Add(1)
         go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
         }(wg, i)
      }
      wg.Wait()
      fmt.Println("exit")
    }

    Ответ: получим deadlock, так wg передается по значению, лучше использовать указатели
    Исправленный код:
        func main() {
        	wg := sync.WaitGroup{}
        	for i := 0; i < 5; i++ {
        		wg.Add(1)
        		go func(wg *sync.WaitGroup, i int) {
        			fmt.Println(i)
        			wg.Done()
        		}(&wg, i)
        	}
        	wg.Wait()
        	fmt.Println("exit")
        }

12.:
    Что выведет данная программа и почему?
    func main() {
      n := 0
      if true {
         n := 1
         n++
      }
      fmt.Println(n)
    }

    Ответ: выведет 0
    Причина заключается в том, что внутри блока условия if true используется та же самая переменная n,
    которая была объявлена во внешней области видимости.
    Внутри блока условия переменная n увеличивается на 1 с помощью оператора n++,
    но это изменение применяется к переменной n внутри блока. Однако, эта переменная имеет область
    видимости только внутри блока условия и не влияет на переменную n во внешней области видимости.
    Поэтому, когда мы печатаем значение переменной n после блока условия, оно равно
    1 - исходному значению переменной во внешней области видимости, поскольку изменение внутри
    блока не повлияло на эту переменную.

13.:
    Что выведет данная программа и почему?

    func someAction(v []int8, b int8) {
      v[0] = 100
      v = append(v, b)
    }

    func main() {
      var a = []int8{1, 2, 3, 4, 5}
      someAction(a, 6)
      fmt.Println(a)
    }

    Ответ: вывод 100,2,3,4,5
    Причина - передаем слайс, слайс это структура, меняем его первый элемент он меняется и в main
    аппендим в слайс новые данные, и уже в функции someAction, возвращается новый слайс ссылающийся на
    другой массив, следовательно этот аппенд не влияет на слайс в main


14.:
    Что выведет данная программа и почему?

    func main() {
      slice := []string{"a", "a"}

      func(slice []string) {
         slice = append(slice, "a")
         slice[0] = "b"
         slice[1] = "b"
         fmt.Print(slice)
      }(slice)
      fmt.Print(slice)
    }

    Ответ: вывод первый в анонимной функции - b b a, в функции main - a a
    Причина - после аппенда в слайс в анонимной функции, появляется новая структура салйса, которая
    ссылается на другой базовый массив, следовательно после этого, операции по смене данных
    по индексам 0,1 будут происходить уже с тем слайсом, который находится в анонимной функции,
    на слайс в main это никак не влияет



